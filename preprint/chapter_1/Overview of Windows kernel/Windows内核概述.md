# Windows内核概述

## 进程与线程

应用程序由一个或多个进程组成。*进程，*用最简单的术语来说，就是执行程序。一个或多个线程在进程的上下文中运行。*线程*是操作系统分配处理器时间的基本单元。线程可以执行进程代码的任何部分，包括当前由另一个线程执行的部分。

<img src=".\src\707ec29c-66ad-4505-9af7-32d6031b23b0.png" alt="707ec29c-66ad-4505-9af7-32d6031b23b0" style="zoom: 33%;" />

*线程池*是代表应用程序高效执行异步回调的工作线程的集合。线程池主要用于减少应用程序线程的数量并提供工作线程的管理。

每个*进程*都提供执行程序所需的资源。进程具有虚拟地址空间、可执行代码、系统对象的开放句柄、安全上下文、唯一进程标识符、环境变量、优先级类、最小和最大工作集大小以及至少一个执行线程。每个进程都是通过单个线程（通常称为主*线程）启动的*，但可以从其任何线程创建其他线程。

下图展示了Windows进程的组成部分：

<img src=".\src\1827556-20200512201103306-2125816182.png" alt="1827556-20200512201103306-2125816182" style="zoom:50%;" />

*线程*是进程中可以计划执行的实体。进程的所有线程共享其虚拟地址空间和系统资源。此外，每个线程维护异常处理程序、计划优先级、线程本地存储、唯一线程标识符以及系统用于保存线程上下文的一组结构，直到计划它。*线程上下文*包括线程的机器寄存器集、内核堆栈、线程环境块和线程进程地址空间中的用户堆栈。线程也可以有自己的安全上下文，可用于模拟客户端。

Windows支持*先发制人的多任务处理*，从而产生从多个进程同时执行多个线程的效果。在多处理器计算机上，系统可以同时执行与计算机上的处理器一样多的线程。

<img src=".\src\Snipaste_2020-11-08_15-03-43.png" alt="Snipaste_2020-11-08_15-03-43" style="zoom:50%;" />

*作业对象*允许将进程组作为一个单元进行管理。作业对象是可远程、安全、可共享的对象，用于控制与其关联的进程的属性。对作业对象执行的操作会影响与作业对象关联的所有进程。

## 服务与系统调用

Windows中的服务，一种运行在后台的计算机程序。它在概念上类似于Unix守护进程。

Windows服务可以配置为在操作系统启动时运行，并且在Windows运行期间持续在后台运行。服务也可以手动或基于某个事件而启动。Windows NT操作系统包含众多服务，分别运行在三种用户帐户环境中：系统、网络服务和本地服务。这些Windows组件通常采用Windows服务托管进程。因为Windows服务运行在其自身的专用用户帐户中，它们可以在用户未登录时活动。

<img src=".\src\windowsservices-serviceswindow.png" alt="windowsservices-serviceswindow" style="zoom:50%;" />

Windows服务也承担了*系统调用*的职能。应用需要执行多种多样的非纯计算性操作，例如分配内存，打开文件，创建线程等。这些操作只能由最终运行在内核模式的代码执行。而用户模式的代码需要通过系统调用来实现这些操作。

例如：一个运行VS Code程序的用户使用文件才来提出打开文件的请求。VS Code的代码通过调用Windows文档中**CreateFile**的API作为回应。**CreateFile**是在**kernel32.dll**中实现的。在之后的一些错误检查中，它调用**NtCreateFile**，一个执行在**Ntdll.dll**中的函数，**Ntdll.dll**是被称为“原生API”的基础DLL，其是用户层最底层的代码。这里，借助Api转换到了内核模式。在实际转换之前，它在寄存器中放入一个数字，被称为系统调用号，之后它使用一个CPU指令来完成实际的内核转换，跳入一个预先设计好的被称为*系统服务派发函数*的例程中。一旦系统服务被完成，线程将通过执行指令 **sysenter/systemcall **来返回用户模式。

<img src="C:\Users\52563\Desktop\src\1827556-20200513163836422-626893615.png" alt="1827556-20200513163836422-626893615" style="zoom: 67%;" />



## 虚拟化

在Windows中，每一个进程有它自己的虚拟，私有，线性的内存，这些地址空间一开始是空的，一旦主线程开始执行，内存则开始可以被分配，并且伴随着更多的Dlls被加载到这段内存中。这地址空间是私有的，其他进程无法直接访问它。这地址空间从0开始，一直到一个最大位。

这个进程本身是被称为虚拟的，这是因为在其内存空间中的*虚拟地址*与一个正确的物理地址之间存在一个间接的关系。在一个进程中的缓冲区可能被映射到物理地址，或者它可能暂时存储在一个文件中（比如一个页文件）。如果这内存确实被映射进RAM中，这CPU可以直接访问数据；否则，这CPU将引发一个页异常，这将使内存管理器的页错误处理程序从正确的页文件中拷贝到RAM中，在缓冲的PTE中进行所需要的更改，之后CPU再次尝试运行一下程序。

<img src=".\src\Snipaste_2020-11-08_15-18-21.png" alt="Snipaste_2020-11-08_15-18-21" style="zoom:50%;" />

## 系统架构

Windows的总体架构由内核态和用户态组成，一个总体的图由相关研究人员如下给出：

<img src="C:\Users\52563\Desktop\src\Snipaste_2020-11-08_15-19-47.png" alt="Snipaste_2020-11-08_15-19-47" style="zoom:50%;" />

以下给出图中各组成模块的解释与描述：

### User Mode 用户模式

- User Processes 是普通的用户进程，它们都依赖于exe文件实例。
- Service Processes 是普通的Windows进程，它与服务控制管理器进行通讯，并且允许在他们的声明周期中进行一些控制。服务管理器可以向这些服务发送消息以控制开始、停止和暂停。 几个典型的服务进程：本地系统、网络服务和本地服务。
- System Processes 在那些无法直接进行通讯的地方做着底层的系统工作。一些系统进程是原生进程，意味着它们仅适用一些原生API（由Ntdll执行的API），例如smss.exe、Lsass.exe、Winlogon.exe、Services.exe以及其他进程。
- Subsystem Process 是Windows的子系统进程，运行着Csrss.exe的镜像，它被认为是Windows系统下内核进程管理的助手。
- Subsystem Dlls 是运行子系统API的动态链接库，这个子系统Dll包含着很多知名的文件，比如kernel32.dll，user32.dll，gdi32.dll，advapi32.dll，combase.dll等。此外，它还包含着Windows系统调用的绝大多数API。

### Kernel Mode 内核模式

- Executive 是NtOskernl.exe的上层，它掌管绝大多数的内核代码。这包含了绝大数的各种管理器 - 对象管理器，内存管理器，I/O管理器，即插即用管理器，电源管理器，配置管理器等，它比底层内核要大得多。
- Kernel 执行了大多数基础的，内核模式下的OS代码，包括线程调度以及各种内核原语（互斥体和信号量等）。一些内核代码是用特定的CPU机器语言所编写的，以提高效率并可以直接访问CPU特定的细节。
- Device Drivers 设备驱动是可加载的内核模块，它们的代码执行在内核模式并且有着全系统的权限。
- Win32k.sys 是Windows子系统的内核模式组件，本质上这是一个内核模块，它用来处理Windows用户界面部分。这意味着所有的窗口操作（CreateWindowEx，GetMessage，PostMessage等）是由这个组件所处理的。
- HardWare Abstraction Layer(HAL) 是一个硬件之上的抽象层。它的作用是允许设备驱动程序的使用不需要中断控制器或DMA控制器等详细和特定知识的api。

